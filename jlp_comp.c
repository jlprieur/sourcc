/* @(#)computer.c	6.1.1.5 (ESO-IPG) 11/23/93 10:32:46 */
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.COPYRIGHT      (c)  1992  European Southern Observatory
.TYPE           Program
.NAME           computer.c
.LANGUAGE       C
.AUTHOR         F.Ochsenbein, IPG/ESO
.CATEGORY       Computer-dependant constants
.COMMENTS       This module generates a suitable computer.h file
                using some simple tests.
.ENVIRONMENT    UNIX 
.VERSION 0.0    19-Oct-1988 : Creation , FO
.VERSION 0.1    18-Aug-1989 : Correct SWAPLONG for PCs, PJG
.VERSION 0.2    09-Jan-1990 : Check IEEE by dividing NaN by itself (FO)
.VERSION 0.3    18-Jan-1991 : DEC reverses the order for IEEE double !!!
.VERSION 0.4    30-Jan-1991 : Double byteswap and NULL, PJG
.VERSION 0.4    12-Feb-1991 : Change VAX NULL to -Inf, PJG
.VERSION 0.5    07-Mar-1991 : Output to file computer.h by default. CG
.VERSION 0.6    11-Sep-1991 : Continuing the test in the interrupt routine. CG.
.VERSION 0.7    21-Sep-1992 : Add Null definitions for tables, PJG.
------------------------------------------------------------*/
/*
 * Define _POSIX_SOURCE to indicate
 * that this is a POSIX program
 */
#define _POSIX_SOURCE 1

#include <stdio.h>
#include <signal.h>

#ifndef DEBUG
#define DEBUG 	0	/* Switch to 1 to get hexa patterns */
#endif

double ldexp();

static char c[80];	/* ... Must be aligned ... */
static int ieee;
static int junk;

static char          *com0 = "/*";
static char          *com1 = "*/";
static unsigned char byte;

/*============================================================================*/

#ifdef __STDC__
static int bit_count(unsigned long u) 
#else
static int bit_count(u)        /* Count number of bits set to 1 */
        unsigned long u;
#endif
{
        int i;

  for (i=0; u; u >>= 1)
        i += u & 1L;
  return(i);
}

#ifdef __STDC__
static void on_fpe(int sig)
#else
static void on_fpe(sig)            /* If Floating point fault, assume IEEE... */
int sig;
#endif
{
    struct sigaction act, oact;

    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = on_fpe;
    sigaction(SIGFPE,&act,&oact);

    if (ieee != 1) {	/* Return if already ieee */
	ieee = 1;
	contin();
	exit(0);
        }
}

/*============================================================================*/

long 	i, dxb;
double 	df, f, f1, f2;
float 	e, e1, e2;
unsigned long 	*pf, *pe;
unsigned long 	*pf1, *pe1;
unsigned long 	*pf2, *pe2;
unsigned long 	usgm, uexp, uman, u;
int 	n, l2e, l2f, nb[3], BITSPERBYTE;

main(argc,argv)
int argc;
char **argv;
{

  struct sigaction act, oact;
	/* Setup pointer to float */

  if (argc > 1) freopen(argv[1],"w",stdout);
  else 		freopen("computer.h","w",stdout);

  pf  = (unsigned long *)&f;
  pe  = (unsigned long *)&e;
  pf1 = (unsigned long *)&f1;
  pe1 = (unsigned long *)&e1;
  pf2 = (unsigned long *)&f2;
  pe2 = (unsigned long *)&e2;
  
        /* Generate Header */

  printf("%s+++++++++++++++++++++++++++++\n", com0);
  puts(".TYPE \t\tHeader");
  puts(".NAME \t\tcomputer.h");
  puts(".LANGUAGE \tC");
  puts(".AUTHOR\t\tESO -- IPG");
  puts(".CATEGORY\tComputer-dependant constants");
  puts(".COMMENTS \tThis module includes constants depending on the computer:");
  puts("\t\tnumber of bits per char,");
  puts("\t\tbyte swapping, description of floating-point numbers. ");
  puts("\t\tLimits also provided for each type of atomic data.");
  puts("\t\tNULL numbers are also defined via isNULL (test) and");
  puts("\t\ttoNULL");
  puts("\t\t********* Generated by computer.c program **************");
  puts(".ENVIRON\tUNIX and VAX/VMS");
  puts(".VERSION \t1.1\t18-Jan-1991 (check Floating Pattern)");
  printf("-----------------------%s\n\n", com1);

  puts("#ifndef BITSPERBYTE\n");

        /* Check first the number of bits per byte */

  for (byte=1, BITSPERBYTE=0; byte; BITSPERBYTE++) {
  	i = byte << 1;
	byte = i;
  }
  printf("#define BITSPERBYTE\t%d\n", BITSPERBYTE);
  puts("#define BITS(type)\t(BITSPERBYTE*((int)sizeof(type)))\n");

  puts("#define ONES_COMP\t1");
  puts("#define TWOS_COMP\t2\n");
  puts("#define IEEEFLOAT\t0");
  puts("#define VAXFLOAT\t1");
  puts("#define VAXGFLOAT\t2");
  puts("#define HPFLOAT\t\t3\n");

        /* Check 1 or 2's Complement    */

  i = -1;
  if (i&1)      /* 2's Complement       */
        printf("#define INTFMT\t\t2\t%s 2's Complement Integers\t%s\n\n", 
		com0,com1);
  else  printf("#define INTFMT\t\t1\t%s 1's Complement Integers\t%s\n\n", 
		com0,com1);


  puts("#define MAXIO1\t\t(512*90)\n\n");
                                /* Maximum allowed for single i/o */

  if (sizeof(int) == sizeof(long))
  {     puts("#define SWAPINT\t\tSWAPLONG");
        puts("#define MAXINT\t\tMAXLONG");
        puts("#define MININT\t\tMINLONG");
        puts("#define MAXUINT\t\tMAXULONG");
        puts("#define isNULLINT\tisNULLLONG");
        puts("#define toNULLINT\ttoNULLLONG");
  }
  else
  {     puts("#define SWAPINT\t\tSWAPSHORT");
        puts("#define MAXINT\t\tMAXSHORT");
        puts("#define MININT\t\tMINSHORT");
        puts("#define MAXUINT\t\tMAXUSHORT");
        puts("#define isNULLINT\tisNULLSHORT");
        puts("#define toNULLINT\ttoNULLSHORT");
  }

#if DEBUG
	e2 = f2 = -1.e0;
	printf("%s Hexa pattern of -1.e0 (float)%08lX", com0,*pe2),
	 printf(" (double)%08lX %08lX\t%s\n",pf2[0],pf2[1], com1);
	e1 = f1 =  1.e0;
	printf("%s Hexa pattern of  1.e0 (float)%08lX", com0,*pe1),
	 printf(" (double)%08lX %08lX\t%s\n",pf1[0],pf1[1], com1);
	e2 = f2 =  2.e0; 
	printf("%s Hexa pattern of  2.e0 (float)%08lX", com0,*pe2),
	 printf(" (double)%08lX %08lX\t%s\n",pf2[0],pf2[1], com1);
	e2 = f2 =  .5e0;
	printf("%s Hexa pattern of  .5e0 (float)%08lX", com0,*pe2),
	 printf(" (double)%08lX %08lX\t%s\n",pf2[0],pf2[1], com1);
	e2 = f2 = .25e0;
	printf("%s Hexa pattern of .25e0 (float)%08lX", com0,*pe2),
	 printf(" (double)%08lX %08lX\t%s\n",pf2[0],pf2[1], com1);
	e2 = f2 =.125e0;
	printf("%s Hexa pattern of.125e0 (float)%08lX", com0,*pe2),
	 printf(" (double)%08lX %08lX\t%s\n",pf2[0],pf2[1], com1);
#endif

        /* Check Swapping       */

  i = ('1'<<BITSPERBYTE) | '2';
  *(short *)c = i, c[2] = 0;
  printf("\n#define SWAPSHORT\t%s\n", c);

  i = ('1'<<BITSPERBYTE) | '2';
  i = (i<<BITSPERBYTE) | '3';
  i = (i<<BITSPERBYTE) | '4';
  *(long *)c = i, c[4] = 0;
  printf("#define SWAPLONG\t%s\n", c);

	/* Find out Dynamic range of Floating-Point */
	/* Note: VAX/VMS approximates (1+2**-24) to (1+2**-23) when 
	   converting from Single to Double precision. That's why
	   there is a second test e1 == e2
	*/
  e = 1.0;
  for (l2e = -32; l2e; l2e++) {
	e1 = 1.0 + ldexp(1.e0, l2e);
	e2 = 1.0 + ldexp(2.e0, l2e);
	if (e1 != e && e1 != e2) break;
      }
  f = 1.0;
  for (l2f = -99; l2f ; l2f++ ) {
	f1 = 1.0 + ldexp(1.e0, l2f);
	f2 = 1.0 + ldexp(2.e0, l2f);
	if (f1 != f && f1 != f2) break;
      }
#if DEBUG
  printf("%s(float)  l2e=%d\tHexa pattern=%08lX, %08lX %s\n", 
	com0,l2e,*pe1,*pe2,com1);
  printf("%s(double) l2f=%d\tHexa pattern=%08lX %08lX, %08lX %08lX %s\n", 
	com0,l2f,pf1[0],pf1[1],pf2[0],pf2[1],com1);
#endif

  for (i=4, e1 = 1.0; i > 1; l2e += BITSPERBYTE, i--) {
	e1 += i*ldexp(1., l2e);
#if DEBUG
	printf("%s(float)  i=%ld l2e=%d\tHexa pattern=%08lX\t%s\n", 
		com0,i,l2e,*pe1,com1);
#endif
  }
  for (i=8, f1 = 1.0; i > 1; l2f += BITSPERBYTE, i--) {
	f1 += i*ldexp(1., l2f); 
#if DEBUG
	printf("%s(double) i=%ld l2f=%d\tHexa pattern=%08lX %08lX\t%s\n", 
		com0,i,l2f,pf1[0],pf1[1],com1);
#endif
  }

  n = sizeof(float);
  *(float *)c = e1, c[n] = 0; 
  for (i=0; i < n; i++)
	if (c[i] >= 1 && c[i] <= n) c[i] += '0';
	else if ((c[i] & 0xf) == 2) c[i] = '2';
	else c[i] = '1';
  printf("#define SWAPFLOAT\t%s\n", c);

  n = sizeof(double);
  *(double *)c = f1, c[n] = 0; 
  for (i=0; i < n; i++)
	if (c[i] >= 1 && c[i] <= n) c[i] += '0';
	else if ((c[i] & 0xf) == 2) c[i] = '2';
	else c[i] = '1';
  printf("#define SWAPDOUBLE\t%s\n\n", c);

        /* Find Integer min / max */

  puts("#define MINCHAR\t\t((char) (1  << (BITS(char)  - 1)))");
  puts("#define MINSHORT\t((short)(1  << (BITS(short) - 1)))");
  puts("#define MINLONG\t\t(       (1L << (BITS(long)  - 1)))\n");

  puts("#define MAXCHAR\t\t((char) (~MINCHAR ))");
  puts("#define MAXSHORT\t((short)(~MINSHORT))");
  puts("#define MAXLONG\t\t(        ~MINLONG )\n");

  puts("#define MAXUCHAR\t((unsigned char) (MINCHAR | MAXCHAR ))");
  puts("#define MAXUSHORT\t((unsigned short)(MINSHORT| MAXSHORT))");
  puts("#define MAXULONG\t((unsigned long) (MINLONG | MAXLONG ))\n\n");

        /* Floating-Point Format        */


	/* Floating-Point Format: determine where are bits for
	   exponent, mantissa, sign, when floating-point number
	   seen as a long int.
	*/

  e1 = 1.e0, e2 = -1.e0;        usgm = *pe1 ^ *pe2;	/* Sign mask */
  e1 = 1.e0; nb[1] = bit_count(*pe1);  		/* Bit Count of 1.e0 */
  e2 = 2.e0; nb[2] = bit_count(*pe2);           /* Bit count of 2.e0 */
  uexp = *pe1 | *pe2;
  e2 = .5e0; nb[0] = bit_count(*pe2);           /* Bit count of .5e0 */
  uexp |= *pe2;
  e2 = .25e0;   uexp |= *pe2;
  e2 = .125e0;  uexp |= *pe2;
  e2 = .0625e0; uexp |= *pe2;
  n = (nb[0] < nb[1] ? nb[0] : nb[1]);
  n = (n < nb[2] ? n : nb[2]);                  /* Minimum      */
  if (n > 1)                                    /* No hidden bit */
  {     if (n == nb[0]) e1 = .5e0;
        if (n == nb[1]) e1 = 1.e0;
        if (n == nb[2]) e1 = 2.e0;
        e2 = e1 / 16.e0;
        uexp &= ~(*pe2 & *pe2);
        n = 0;
  }
  uman = ~(usgm|uexp);

        /* Check IEEE : Divide a number by itself...   */

  e1 = .1e0;  *pe1 |= uexp;	/* This gives a number in the NaN range */
  ieee = 0;   e2 = e1;

  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
  act.sa_handler = on_fpe;
  sigaction(SIGFPE,&act,&oact);

#if DEBUG
	printf("%s Edited floating-point NULL number is %e %s\n",
	       com0, e1,com1);
	printf("%s Edited floating-point NULL number is %e %s\n",
	       com0, e2,com1);
	printf("%s        Ratio is       NULL  ?     is %e %s\n\n",
	       com0,e1/e2,com1);
#endif
  e2 = e1/e2;
  if ( ieee == 1) exit(0); /* Interrrupt already arrived, so exit */
  contin();
  exit(0);
}

contin()
{  
  if (ieee == 0)	ieee = (e2 != 1.e0);

  printf("#define _IEEE\t\t%d\t%s NULL edited as %e %s\n", 
	ieee, com0, e1, com1);
  printf("#define _HIDDENBIT\t%d\n", n);

  e1 = 1.e0; e2 = 2.e0;

  if ((*pe1 & uman) == (*pe2 & uman))
        puts("#define _EXPBASE\t2\n");
  else  puts("#define _EXPBASE\t16\n");


  printf("#define _FEXPLEN\t%d\n", bit_count(uexp));
  printf("#define FMASKSGM\t0x%08lX\n", usgm);
  printf("#define FMASKEXP\t0x%08lX\n", uexp);
  printf("#define FMASKMAN\t0x%08lX\n\n", uman);

  if (ieee)     puts("#define MAXFLOAT\t((float)3.40282346638528860e+38)"),
                puts("#define MINFLOAT\t((float)1.40129846432481707e-45)\n");
  else
  {     *pe1 = uexp | uman;
        printf("#define MAXFLOAT\t(float)%24.17e\n", e1);
        for (u=uexp, i=0; (u&1) == 0; i++, u >>= 1);
        *pe1 = (1L) << i;
        printf("#define MINFLOAT\t(float)%24.17e\n\n", e1);
  }

#if DEBUG
	f1 = 1.0e0; f2 = -1.0e0;
	printf("%s\t==== Double Precision Numbers ====%s\n",com0,com1);
	printf("%s Hexa pattern of -1.e0: %08lX %08lX%s \n",
	       com0,*pf2, pf2[1],com1);
	printf("%s Hexa pattern of  1.e0: %08lX %08lX%s \n",
	       com0,*pf1, pf1[1],com1);
	f2 = 2.e0;
	printf("%s Hexa pattern of  2.e0: %08lX %08lX%s \n",
	       com0,*pf2, pf2[1],com1);
	f2 =  .5e0;
	printf("%s Hexa pattern of  .5e0: %08lX %08lX%s \n",
	       com0,*pf2, pf2[1],com1);
	f2 = .25e0;
	printf("%s Hexa pattern of .25e0: %08lX %08lX%s \n",
	       com0,*pf2, pf2[1],com1);
	f2 =.125e0;
	printf("%s Hexa pattern of.125e0: %08lX %08lX%s \n",
	       com0,*pf2,pf2[1],com1);
#endif

  f1 = 1.e0, f2 = -1.e0;
  dxb = (pf1[0] ? 0 : 1);
  usgm = pf1[dxb] ^ pf2[dxb];
  nb[1] = bit_count(pf1[dxb]);			/* Bit Count of 1.e0 */
  f2 = 2.e0; nb[2] = bit_count(pf2[dxb]);     	/* Bit count of 2.e0 */
  uexp = pf2[dxb] | pf2[dxb];
  f2 = .5e0; nb[0] = bit_count(pf2[dxb]);      	/* Bit count of .5e0 */
  uexp |= pf2[dxb];
  f2 = .25e0;   uexp |= pf2[dxb];
  f2 = .125e0;  uexp |= pf2[dxb];
  f2 = .0625e0; uexp |= pf2[dxb];
  printf("#define _DEXPLEN\t%d\n", bit_count(uexp));
  printf("#define DLONGEXP\t%ld\t%s Exponent is in longword #%ld\t%s\n",
	 dxb,com0,dxb,com1);
  printf("#define DMASKSGM\t0x%08lX\n", usgm);
  printf("#define DMASKEXP\t0x%08lX\n", uexp);
  printf("#define DMASKMAN\t0x%08lX\n\n", ~(usgm|uexp));

  if (ieee)     puts("#define MAXDOUBLE\t1.79769313486231166e+308"),
                puts("#define MINDOUBLE\t4.94065645841246544e-324\n");
  else
  {     *pf1 = uexp | uman; *(pf1+1) = ~0;
        printf("#define MAXDOUBLE\t%24.17e\n", f1);
        for (u=uexp, i=0; (u&1) == 0; i++, u >>= 1);
        *pf1 = (1L) << i; *(pf1+1) = 0;
        printf("#define MINDOUBLE\t%24.17e\n\n", f1);
  }

        /* Definitions of NULL's */

  printf("%s\t Definition of NULL's \t%s\n\n",com0,com1);
  puts("#define asaULONG(x)\t(unsigned long *)(&(x))\n");

  puts("#define NULL1\t\t(MINCHAR)");
  puts("#define NULL2\t\t(MINSHORT)");
  puts("#define NULL4\t\t(MINLONG)\n");

  puts("#define isNULLSHORT(x)\t((short)(x) == MINSHORT)");
  puts("#define toNULLSHORT(x)\tx = MINSHORT\n");

  puts("#define isNULLLONG(x)\t((long)(x) == MINLONG)");
  puts("#define toNULLLONG(x)\tx = MINLONG\n");

  if (ieee)
  { 
    printf("%s\t Use -Inf as NULL for IEEE fp \t%s\n\n",com0,com1);
    e1 = -1.0; e2 = e1 + 1.0; e = e1/e2; 
    printf("#define NULLF\t\t(FMASKSGM | FMASKEXP)\n");
    printf("#define isNULLFLOAT(x)\t(*asaULONG(x) == NULLF)\n");
    printf("#define toNULLFLOAT(x)\t *asaULONG(x) = NULLF\n");

    f1 = -1.0; f2 = f1 + 1.0; f = f1/f2;
    printf("#define NULLD\t\t(DMASKSGM | DMASKEXP)\n");
    printf("#define isNULLDOUBLE(x)\t");
    printf("((*(asaULONG(x)+DLONGEXP) == NULLD) &&  \\\n");
    printf("\t\t\t (*(asaULONG(x)+(DLONGEXP^1)) == 0))\n");
    printf("#define toNULLDOUBLE(x)\t");
    printf("*(asaULONG(x)+DLONGEXP) = NULLD, \\\n");
    printf("\t\t\t *(asaULONG(x)+(DLONGEXP^1)) = 0\n\n");

  }
  else
  { 
    printf("#define NULLF\t\t(~FMASKSGM)\n");
    printf("#define NULLD\t\t(DMASKSGM | DMASKEXP)\n");
    puts("#define isNULLFLOAT(x)\t(*asaULONG(x) == NULLF)");
    puts("#define toNULLFLOAT(x)\t*asaULONG(x) = NULLF");

    printf("#define isNULLDOUBLE(x)\t");
    printf("((*(asaULONG(x)+DLONGEXP) == NULLD) &&  \\\n");
    printf("\t\t\t (*(asaULONG(x)+(DLONGEXP^1)) == 0))\n");
    printf("#define toNULLDOUBLE(x)\t");
    printf("*(asaULONG(x)+DLONGEXP) = NULLD, \\\n");
    printf("\t\t\t *(asaULONG(x)+(DLONGEXP^1)) = 0\n\n");
  }

  puts("#define FSIGNIF\t\t(BITS(float)  - _FEXPLEN + _HIDDENBIT - 1)");
  puts("#define DSIGNIF\t\t(BITS(double) - _DEXPLEN + _HIDDENBIT - 1)");
  puts("#define FMAXEXP\t\t((1 << (_FEXPLEN - 1)) - 1 + _IEEE)");
  puts("#define DMAXEXP\t\t((1 << (_DEXPLEN - 1)) - 1 + _IEEE)\n\n");

  if (ieee) puts("#define FLOATFMT\tIEEEFLOAT");
  else if ( (uexp == 0x7f80) || (uexp == 0x7ff0) ) {
    if ( bit_count(uexp) < 10 )
        puts("#define FLOATFMT\tVAXFLOAT");
    else
        puts("#define FLOATFMT\tVAXGFLOAT");
    }
  else {
	fputs("ERROR: Undefined floating point format\n",stderr);
	exit(1);
	}

  puts("\n#endif");
  exit(0);
}
